sort1 uses: Bubble Sort

How do you know?: Going back to the charateristics of the Bubble Sort Algorithm, we can see on various running time
                that Sort 1 program becomes slower with larger files especially on unsorted arrays but shows evident
                changes with sorted files.
                The worst case scenario O(n^2) is visible with larger arrays of 10000 to 50000 textsts and declined
                even more with the reversed text files where each large element must be bubbled across the entire array
                to its correct position. Simultaneously, small elements also need to be bubbled back across the
                array.
                The best case scenario Î©(n) is the efficient attribute of the Sort 1(Bubble Sort). When we run the already
                sorted files, the steps changes to more effective steps, skipping the first procedures of its worst case.
                Since the files are already, running time is also reduced and there is no need to swap elements
                since they are already in order.

                here is only a very
                small time difference between running the unsorted and sorted files. The sorted files is actually
                faster since the files(arrays) are already sorted. We can conclude that its worse case n squared wherein
                we have to iterate across all the n elements n times while for the best case, if the array is perfectly
                sorted, we only have to look at each of the elements once.
                Comparing Sort 2(which I proposed is the Merge Sort), Sort 3 Algorithm with sorted files are as efficient as Sort
                2.

sort2 uses: Merge Sort

How do you know?: After conducting the timing tests, Sort 2 shows fast user time which
                corresponds with the characteristics of a Merge Sort. Aside from its efficiency, I also
                observed that the time difference between real and sys time are very minimal. The timings are
                consistent during the other tests with larger files too. Merge Sort has the same worst case
                and best case scenarios in the file examples. It is O of n log n, which we use the same
                process with sorted and unsorted files. Even though we are repeating the same steps with sorted
                unsorted files, the speed is still fast and efficient.

sort3 uses: Selection Sort

How do you know?: Among the options of Sort Algorithms, Sort 3 has the slowest outcome and its time run
                for sorted and unsorted files are very similar. They consume more time than the other two sort
                programs. It means that with Selection Sort, we go through every single element of the array
                in order to confirm the smallest element and the same steps is repeated even if the arrays
                are already sorted. n times, once for each of n elements. Therefore, its worst and best case scenario
                is not a very ideal sort algorithm.
